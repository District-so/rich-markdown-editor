webpackHotUpdate("main",{

/***/ "./src/nodes/Image.tsx":
/*!*****************************!*\
  !*** ./src/nodes/Image.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\nconst prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ \"./node_modules/prosemirror-inputrules/dist/index.js\");\nconst prosemirror_utils_1 = __webpack_require__(/*! prosemirror-utils */ \"./node_modules/prosemirror-utils/dist/index.js\");\nconst styled_components_1 = __importDefault(__webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.cjs.js\"));\nconst react_medium_image_zoom_1 = __importDefault(__webpack_require__(/*! react-medium-image-zoom */ \"./node_modules/react-medium-image-zoom/lib/index.js\"));\nconst getDataTransferFiles_1 = __importDefault(__webpack_require__(/*! ../lib/getDataTransferFiles */ \"./src/lib/getDataTransferFiles.ts\"));\nconst uploadPlaceholder_1 = __importDefault(__webpack_require__(/*! ../lib/uploadPlaceholder */ \"./src/lib/uploadPlaceholder.ts\"));\nconst insertFiles_1 = __importDefault(__webpack_require__(/*! ../commands/insertFiles */ \"./src/commands/insertFiles.ts\"));\nconst Node_1 = __importDefault(__webpack_require__(/*! ./Node */ \"./src/nodes/Node.ts\"));\nconst IMAGE_INPUT_REGEX = /!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\)/;\nconst CENTER_STYLE = {\n    display: \"inline-block\",\n    maxWidth: \"100%\",\n    maxHeight: \"75vh\",\n};\nconst FULL_WIDTH_STYLE = {\n    display: \"block\",\n    width: \"100%\",\n    maxHeight: \"100%\",\n};\nconst THUMBNAIL_STYLE = {\n    display: \"inline-block\",\n    maxWidth: \"100%\",\n    maxHeight: \"250px\",\n};\nconst uploadPlugin = options => new prosemirror_state_1.Plugin({\n    props: {\n        handleDOMEvents: {\n            paste(view, event) {\n                if ((view.props.editable && !view.props.editable(view.state)) ||\n                    !options.uploadImage) {\n                    return false;\n                }\n                if (!event.clipboardData)\n                    return false;\n                const files = Array.prototype.slice\n                    .call(event.clipboardData.items)\n                    .map(dt => dt.getAsFile())\n                    .filter(file => file);\n                if (files.length === 0)\n                    return false;\n                const { tr } = view.state;\n                if (!tr.selection.empty) {\n                    tr.deleteSelection();\n                }\n                const pos = tr.selection.from;\n                insertFiles_1.default(view, event, pos, files, options);\n                return true;\n            },\n            drop(view, event) {\n                if ((view.props.editable && !view.props.editable(view.state)) ||\n                    !options.uploadImage) {\n                    return false;\n                }\n                const files = getDataTransferFiles_1.default(event).filter(file => /image/i.test(file.type));\n                if (files.length === 0) {\n                    return false;\n                }\n                const result = view.posAtCoords({\n                    left: event.clientX,\n                    top: event.clientY,\n                });\n                if (result) {\n                    insertFiles_1.default(view, event, result.pos, files, options);\n                    return true;\n                }\n                return false;\n            },\n        },\n    },\n});\nclass Image extends Node_1.default {\n    constructor() {\n        super(...arguments);\n        this.handleAlignmentChange = ({ node, getPos }) => event => {\n            const src = node.attrs.src;\n            const alt = node.attrs.alt;\n            const alignment = event.target.value;\n            if (alignment === node.attrs.alignment)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                src,\n                alignment,\n                alt,\n            });\n            view.dispatch(transaction);\n        };\n        this.handleKeyDown = ({ node, getPos }) => event => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                const { view } = this.editor;\n                const pos = getPos() + node.nodeSize;\n                view.focus();\n                view.dispatch(prosemirror_utils_1.setTextSelection(pos)(view.state.tr));\n                return;\n            }\n            if (event.key === \"Backspace\" && event.target.innerText === \"\") {\n                const { view } = this.editor;\n                const $pos = view.state.doc.resolve(getPos());\n                const tr = view.state.tr.setSelection(new prosemirror_state_1.NodeSelection($pos));\n                view.dispatch(tr.deleteSelection());\n                view.focus();\n                return;\n            }\n        };\n        this.handleBlur = ({ node, getPos }) => event => {\n            const alt = event.target.innerText;\n            const src = node.attrs.src;\n            if (alt === node.attrs.alt)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                src,\n                alt,\n            });\n            view.dispatch(transaction);\n        };\n        this.handleSelect = ({ getPos }) => event => {\n            event.preventDefault();\n        };\n        this.component = props => {\n            const { theme, isEditable, isSelected } = props;\n            const { alt, alignment, src } = props.node.attrs;\n            return (React.createElement(\"div\", { contentEditable: false, className: \"image\" },\n                React.createElement(ImageWrapper, { className: alignment + \" image-block \" + (isSelected ? \"ProseMirror-selectednode\" : \"\"), onClick: isEditable ? this.handleSelect(props) : undefined },\n                    React.createElement(\"div\", { contentEditable: false },\n                        React.createElement(\"select\", { value: alignment, onChange: this.handleAlignmentChange(props) }, this.alignmentOptions.map(([key, label], index) => (React.createElement(\"option\", { key: key, value: key }, label))))),\n                    React.createElement(react_medium_image_zoom_1.default, { image: {\n                            src,\n                            alt,\n                            style: this.alignmentStyles[alignment],\n                        }, defaultStyles: {\n                            overlay: {\n                                backgroundColor: theme.background,\n                            },\n                        }, shouldRespectMaxDimension: true })),\n                (isEditable || alt) && (React.createElement(Caption, { onKeyDown: this.handleKeyDown(props), onBlur: this.handleBlur(props), tabIndex: -1, contentEditable: isEditable, suppressContentEditableWarning: true }, alt))));\n        };\n    }\n    get alignmentOptions() {\n        return Object.entries({\n            center: this.options.dictionary.center,\n            full_width: this.options.dictionary.fullWidth,\n            thumbnail: this.options.dictionary.thumbnail,\n        });\n    }\n    get alignmentStyles() {\n        return {\n            center: CENTER_STYLE,\n            full_width: FULL_WIDTH_STYLE,\n            thumbnail: THUMBNAIL_STYLE,\n        };\n    }\n    get name() {\n        return \"image\";\n    }\n    get schema() {\n        return {\n            inline: true,\n            attrs: {\n                src: {},\n                alignment: {\n                    default: \"center\"\n                },\n                alt: {\n                    default: null,\n                },\n            },\n            content: \"text*\",\n            marks: \"\",\n            group: \"inline\",\n            selectable: true,\n            draggable: true,\n            parseDOM: [\n                {\n                    tag: \"div[class=image]\",\n                    getAttrs: (dom) => {\n                        const img = dom.getElementsByTagName(\"img\")[0];\n                        const caption = dom.getElementsByTagName(\"p\")[0];\n                        return {\n                            src: img.getAttribute(\"src\"),\n                            alt: caption.innerText,\n                        };\n                    },\n                },\n            ],\n            toDOM: node => {\n                const select = document.createElement(\"select\");\n                select.addEventListener(\"change\", this.handleAlignmentChange);\n                this.alignmentOptions.forEach(([key, label]) => {\n                    const option = document.createElement(\"option\");\n                    option.value = key;\n                    option.innerText = label;\n                    option.selected = node.attrs.alignment === key;\n                    select.appendChild(option);\n                });\n                return [\n                    \"div\",\n                    {\n                        class: \"image\",\n                    },\n                    [\n                        \"div\",\n                        { class: \"image-block \" + node.attrs.alignment },\n                        [\"div\", { contentEditable: false }, select],\n                        [\"img\", Object.assign(Object.assign({}, node.attrs), { contentEditable: false })],\n                    ],\n                    [\"p\", { class: \"caption\" }, 0],\n                ];\n            },\n        };\n    }\n    toMarkdown(state, node) {\n        state.write(\"![\" +\n            state.esc((node.attrs.alt || \"\").replace(\"\\n\", \"\") || \"\") +\n            \"](\" +\n            state.esc(node.attrs.src) +\n            \")\" +\n            \"{alignment=\" + node.attrs.alignment + \"}\");\n    }\n    parseMarkdown() {\n        return {\n            node: \"image\",\n            getAttrs: token => ({\n                src: token.attrGet(\"src\"),\n                alignment: token.attrGet(\"alignment\"),\n                alt: (token.children[0] && token.children[0].content) || null,\n            }),\n        };\n    }\n    commands({ type }) {\n        return attrs => (state, dispatch) => {\n            const { selection } = state;\n            const position = selection.$cursor\n                ? selection.$cursor.pos\n                : selection.$to.pos;\n            const node = type.create(attrs);\n            const transaction = state.tr.insert(position, node);\n            dispatch(transaction);\n            return true;\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(IMAGE_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, alt, src] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start - 1, end, type.create({\n                        src,\n                        alt,\n                    }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    get plugins() {\n        return [uploadPlaceholder_1.default, uploadPlugin(this.options)];\n    }\n}\nexports.default = Image;\nconst ImageWrapper = styled_components_1.default.span `\n  \n`;\nconst Caption = styled_components_1.default.p `\n  border: 0;\n  display: block;\n  font-size: 13px;\n  font-style: italic;\n  color: ${props => props.theme.textSecondary};\n  padding: 2px 0;\n  line-height: 16px;\n  text-align: center;\n  width: 100%;\n  min-height: 1em;\n  outline: none;\n  background: none;\n  resize: none;\n\n  &:empty:before {\n    color: ${props => props.theme.placeholder};\n    content: \"Write a caption\";\n    pointer-events: none;\n  }\n`;\n\n\n//# sourceURL=webpack:///./src/nodes/Image.tsx?");

/***/ })

})