webpackHotUpdate("main",{

/***/ "./src/nodes/Button.tsx":
/*!******************************!*\
  !*** ./src/nodes/Button.tsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst prosemirror_commands_1 = __webpack_require__(/*! prosemirror-commands */ \"./node_modules/prosemirror-commands/dist/index.js\");\nconst prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\nconst prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ \"./node_modules/prosemirror-inputrules/dist/index.js\");\nconst Node_1 = __importDefault(__webpack_require__(/*! ./Node */ \"./src/nodes/Node.ts\"));\nconst prosemirror_utils_1 = __webpack_require__(/*! prosemirror-utils */ \"./node_modules/prosemirror-utils/dist/index.js\");\nconst styled_components_1 = __importDefault(__webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.cjs.js\"));\nconst BUTTON_INPUT_REGEX = /\\[\\{(.+)\\}\\{(.+)\\}\\](\\S+)\\)/;\nclass Button extends Node_1.default {\n    constructor() {\n        super(...arguments);\n        this.handleStyleChange = ({ node, getPos }) => event => {\n            const title = node.attrs.title;\n            const href = node.attrs.href;\n            const style = event.target.value;\n            if (style === node.attrs.style)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                href,\n                title,\n                style,\n            });\n            view.dispatch(transaction);\n        };\n        this.handleKeyDown = ({ node, getPos }) => event => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                const { view } = this.editor;\n                const pos = getPos() + node.nodeSize;\n                view.focus();\n                view.dispatch(prosemirror_utils_1.setTextSelection(pos)(view.state.tr));\n                return;\n            }\n            if (event.key === \"Backspace\" && event.target.innerText === \"\") {\n                const { view } = this.editor;\n                const $pos = view.state.doc.resolve(getPos());\n                const tr = view.state.tr.setSelection(new prosemirror_state_1.NodeSelection($pos));\n                view.dispatch(tr.deleteSelection());\n                view.focus();\n                return;\n            }\n        };\n        this.handleBlur = ({ node, getPos }) => event => {\n            const title = event.target.innerText;\n            const href = node.attrs.href;\n            const style = node.attrs.style;\n            if (title === node.attrs.title)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                href,\n                title,\n                style,\n            });\n            view.dispatch(transaction);\n        };\n        this.handleSelect = ({ getPos }) => event => {\n            event.preventDefault();\n            const { view } = this.editor;\n            const $pos = view.state.doc.resolve(getPos());\n            const transaction = view.state.tr.setSelection(new prosemirror_state_1.NodeSelection($pos));\n            view.dispatch(transaction);\n        };\n        this.component = props => {\n            const { theme, isEditable, isSelected } = props;\n            const { href, title, style } = props.node.attrs;\n            return (React.createElement(ButtonWrapper, { contentEditable: false, className: \"button-block\", onClick: isEditable ? this.handleSelect(props) : undefined, title: title },\n                React.createElement(\"div\", { contentEditable: false },\n                    React.createElement(\"select\", { value: style, onChange: this.handleStyleChange(props) }, this.styleOptions.map(([key, label], index) => (React.createElement(\"option\", { key: key, value: key }, label))))),\n                React.createElement(ButtonTitle, { onKeyDown: this.handleKeyDown(props), onBlur: this.handleBlur(props), href: href, rel: \"noreferrer nofollow\", contentEditable: isEditable, suppressContentEditableWarning: true, className: \"btn btn-md btn-\" + style }, title)));\n        };\n    }\n    get styleOptions() {\n        return Object.entries({\n            primary: this.options.dictionary.primary,\n            secondary: this.options.dictionary.secondary,\n            success: this.options.dictionary.success,\n            warning: this.options.dictionary.warning,\n            danger: this.options.dictionary.danger,\n            info: this.options.dictionary.info,\n            white: this.options.dictionary.white,\n            light: this.options.dictionary.light,\n            dark: this.options.dictionary.dark,\n        });\n    }\n    get name() {\n        return \"button\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                href: {\n                    default: \"\",\n                },\n                title: {\n                    default: \"\",\n                },\n                style: {\n                    default: \"primary\",\n                },\n            },\n            content: \"inline*\",\n            group: \"block\",\n            inclusive: false,\n            selectable: true,\n            draggable: true,\n            parseDOM: [\n                {\n                    tag: \"div.button-block\",\n                    getAttrs: (dom) => {\n                        const aElem = dom.getElementsByTagName(\"a\")[0];\n                        let style = undefined;\n                        this.styleOptions.forEach(([key, label]) => {\n                            if (dom.className.includes(key)) {\n                                style = key;\n                                return;\n                            }\n                        });\n                        return {\n                            href: aElem.getAttribute(\"href\"),\n                            title: aElem.getAttribute(\"title\"),\n                            style: style,\n                        };\n                    },\n                },\n            ],\n            toDOM: node => {\n                const select = document.createElement(\"select\");\n                select.addEventListener(\"change\", this.handleStyleChange);\n                this.styleOptions.forEach(([key, label]) => {\n                    const option = document.createElement(\"option\");\n                    option.value = key;\n                    option.innerText = label;\n                    option.selected = node.attrs.style === key;\n                    select.appendChild(option);\n                });\n                return [\n                    \"div\",\n                    { class: `button-block ${node.attrs.style}` },\n                    [\"div\", { contentEditable: false }, select],\n                    [\n                        \"a\",\n                        {\n                            href: node.attrs.href,\n                            rel: \"noopener noreferrer nofollow\",\n                            class: `btn btn-md btn-${node.attrs.style}`,\n                            title: node.attrs.title\n                        },\n                        0\n                    ],\n                ];\n            },\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(BUTTON_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, title, style, href] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start, end, this.editor.schema.text(title)).setBlockType(start, start + title.length, state.schema.nodes.button, { href, title, style });\n                }\n                return tr;\n            }),\n        ];\n    }\n    commands({ type }) {\n        return ({ href } = { href: \"\" }) => prosemirror_commands_1.toggleMark(type, { href });\n    }\n    get plugins() {\n        return [\n            new prosemirror_state_1.Plugin({\n                props: {\n                    handleDOMEvents: {\n                        mouseover: (view, event) => {\n                            if (event.target instanceof HTMLAnchorElement &&\n                                !event.target.className.includes(\"ProseMirror-widget\")) {\n                                if (this.options.onHoverLink) {\n                                    return this.options.onHoverLink(event);\n                                }\n                            }\n                            return false;\n                        },\n                        click: (view, event) => {\n                            if (view.props.editable &&\n                                view.props.editable(view.state) &&\n                                !event.metaKey) {\n                                return false;\n                            }\n                            if (event.target instanceof HTMLAnchorElement) {\n                                const href = event.target.href ||\n                                    (event.target.parentNode instanceof HTMLAnchorElement\n                                        ? event.target.parentNode.href\n                                        : \"\");\n                                const isHashtag = href.startsWith(\"#\");\n                                if (isHashtag && this.options.onClickHashtag) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickHashtag(href, event);\n                                    return true;\n                                }\n                                if (this.options.onClickLink) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickLink(href, event);\n                                    return true;\n                                }\n                            }\n                            return false;\n                        },\n                    },\n                },\n            }),\n        ];\n    }\n    toMarkdown(state, node) {\n        state.ensureNewLine();\n        state.write(\"[\" + node.attrs.title + \"](\" + node.attrs.href + \"){style=\" + node.attrs.style + \"}\");\n        state.write(\"\\n\\n\");\n    }\n    parseMarkdown() {\n        return {\n            node: \"button\",\n            getAttrs: tok => ({\n                href: tok.attrGet(\"href\"),\n                style: tok.attrGet(\"style\") || null,\n                title: tok.attrGet(\"title\") || null,\n            }),\n        };\n    }\n}\nexports.default = Button;\nconst ButtonWrapper = styled_components_1.default.div `\n  display: flex;\n  justify-content: center;\n  width: 100%;\n  padding-top: 1.5rem;\n  padding-botton: 1.5rem;\n`;\nconst ButtonTitle = styled_components_1.default.a `\n  \n`;\n\n\n//# sourceURL=webpack:///./src/nodes/Button.tsx?");

/***/ })

})