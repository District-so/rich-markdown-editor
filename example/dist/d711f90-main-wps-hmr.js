webpackHotUpdate("main",{

/***/ "./src/nodes/Button.tsx":
/*!******************************!*\
  !*** ./src/nodes/Button.tsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_commands_1 = __webpack_require__(/*! prosemirror-commands */ \"./node_modules/prosemirror-commands/dist/index.js\");\nconst prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\nconst prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ \"./node_modules/prosemirror-inputrules/dist/index.js\");\nconst Node_1 = __importDefault(__webpack_require__(/*! ./Node */ \"./src/nodes/Node.ts\"));\nconst getNodeRange_1 = __importDefault(__webpack_require__(/*! ../queries/getNodeRange */ \"./src/queries/getNodeRange.ts\"));\nconst BUTTON_INPUT_REGEX = /\\{\\[(.+)\\],\\s?\\[(.*)\\],\\s?\\[(.*)\\]\\}\\((\\S+)\\)/;\nclass Button extends Node_1.default {\n    constructor() {\n        super(...arguments);\n        this.handleStyleChange = event => {\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const element = event.target;\n            const { top, left } = element.getBoundingClientRect();\n            const result = view.posAtCoords({ top, left });\n            if (result) {\n                const range = getNodeRange_1.default(view.state.schema.nodes.button)(view.state);\n                const transaction = tr.setNodeMarkup(result.inside, undefined, {\n                    style: element.value,\n                    title: range.node.attrs.title,\n                    href: range.node.attrs.href\n                });\n                view.dispatch(transaction);\n            }\n        };\n    }\n    get styleOptions() {\n        return Object.entries({\n            primary: this.options.dictionary.primary,\n            secondary: this.options.dictionary.secondary,\n            success: this.options.dictionary.success,\n            warning: this.options.dictionary.warning,\n            danger: this.options.dictionary.danger,\n            info: this.options.dictionary.info,\n            white: this.options.dictionary.white,\n            light: this.options.dictionary.light,\n            dark: this.options.dictionary.dark,\n        });\n    }\n    get name() {\n        return \"button\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                href: {\n                    default: \"\",\n                },\n                title: {\n                    default: \"\",\n                },\n                style: {\n                    default: \"primary\",\n                },\n            },\n            content: \"text*\",\n            group: \"block\",\n            marks: \"\",\n            parseDOM: [\n                {\n                    tag: \"a[href]\",\n                    getAttrs: (dom) => ({\n                        href: dom.getAttribute(\"href\"),\n                        title: dom.getAttribute(\"title\"),\n                        style: dom.getAttribute(\"subtitle\"),\n                    }),\n                },\n            ],\n            toDOM: node => {\n                const select = document.createElement(\"select\");\n                select.addEventListener(\"change\", this.handleStyleChange);\n                this.styleOptions.forEach(([key, label]) => {\n                    const option = document.createElement(\"option\");\n                    option.value = key;\n                    option.innerText = label;\n                    option.selected = node.attrs.style === key;\n                    select.appendChild(option);\n                });\n                return [\n                    \"div\",\n                    { class: \"d-flex justify-content-center btn-block\" },\n                    [\"div\", { contentEditable: false }, select],\n                    [\n                        \"a\",\n                        {\n                            href: node.attrs.href,\n                            rel: \"noopener noreferrer nofollow\",\n                            class: `btn btn-${node.attrs.style}`\n                        },\n                        0\n                    ],\n                ];\n            },\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(BUTTON_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, title, subtitle, image, href] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start, end, this.editor.schema.text(alt)).addMark(start, start + alt.length, type.create({ href }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    commands({ type }) {\n        return ({ href } = { href: \"\" }) => prosemirror_commands_1.toggleMark(type, { href });\n    }\n    get plugins() {\n        return [\n            new prosemirror_state_1.Plugin({\n                props: {\n                    handleDOMEvents: {\n                        mouseover: (view, event) => {\n                            if (event.target instanceof HTMLAnchorElement &&\n                                !event.target.className.includes(\"ProseMirror-widget\")) {\n                                if (this.options.onHoverLink) {\n                                    return this.options.onHoverLink(event);\n                                }\n                            }\n                            return false;\n                        },\n                        click: (view, event) => {\n                            if (view.props.editable &&\n                                view.props.editable(view.state) &&\n                                !event.metaKey) {\n                                return false;\n                            }\n                            if (event.target instanceof HTMLAnchorElement) {\n                                const href = event.target.href ||\n                                    (event.target.parentNode instanceof HTMLAnchorElement\n                                        ? event.target.parentNode.href\n                                        : \"\");\n                                const isHashtag = href.startsWith(\"#\");\n                                if (isHashtag && this.options.onClickHashtag) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickHashtag(href, event);\n                                    return true;\n                                }\n                                if (this.options.onClickLink) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickLink(href, event);\n                                    return true;\n                                }\n                            }\n                            return false;\n                        },\n                    },\n                },\n            }),\n        ];\n    }\n    toMarkdown(state, node) {\n        state.ensureNewLine();\n        state.write(\"[{\" + node.textContent + \"}{\" + node.attrs.style + \"}](\" + node.attrs.href + \")\");\n        state.write(\"\\n\\n\");\n    }\n    parseMarkdown() {\n        return {\n            node: \"button\",\n            getAttrs: tok => ({\n                test: console.log('button', tok),\n                href: tok.attrGet(\"href\"),\n                style: tok.attrGet(\"style\") || null,\n                title: tok.attrGet(\"title\") || null,\n            }),\n        };\n    }\n}\nexports.default = Button;\n\n\n//# sourceURL=webpack:///./src/nodes/Button.tsx?");

/***/ })

})