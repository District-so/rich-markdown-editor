webpackHotUpdate("main",{

/***/ "./src/nodes/Image.tsx":
/*!*****************************!*\
  !*** ./src/nodes/Image.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\nconst prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ \"./node_modules/prosemirror-inputrules/dist/index.js\");\nconst prosemirror_utils_1 = __webpack_require__(/*! prosemirror-utils */ \"./node_modules/prosemirror-utils/dist/index.js\");\nconst styled_components_1 = __importDefault(__webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.cjs.js\"));\nconst react_medium_image_zoom_1 = __importDefault(__webpack_require__(/*! react-medium-image-zoom */ \"./node_modules/react-medium-image-zoom/lib/index.js\"));\nconst getDataTransferFiles_1 = __importDefault(__webpack_require__(/*! ../lib/getDataTransferFiles */ \"./src/lib/getDataTransferFiles.ts\"));\nconst uploadPlaceholder_1 = __importDefault(__webpack_require__(/*! ../lib/uploadPlaceholder */ \"./src/lib/uploadPlaceholder.ts\"));\nconst insertFiles_1 = __importDefault(__webpack_require__(/*! ../commands/insertFiles */ \"./src/commands/insertFiles.ts\"));\nconst Node_1 = __importDefault(__webpack_require__(/*! ./Node */ \"./src/nodes/Node.ts\"));\nconst IMAGE_INPUT_REGEX = /!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\)/;\nconst uploadPlugin = options => new prosemirror_state_1.Plugin({\n    props: {\n        handleDOMEvents: {\n            paste(view, event) {\n                if ((view.props.editable && !view.props.editable(view.state)) ||\n                    !options.uploadImage) {\n                    return false;\n                }\n                if (!event.clipboardData)\n                    return false;\n                const files = Array.prototype.slice\n                    .call(event.clipboardData.items)\n                    .map(dt => dt.getAsFile())\n                    .filter(file => file);\n                if (files.length === 0)\n                    return false;\n                const { tr } = view.state;\n                if (!tr.selection.empty) {\n                    tr.deleteSelection();\n                }\n                const pos = tr.selection.from;\n                insertFiles_1.default(view, event, pos, files, options);\n                return true;\n            },\n            drop(view, event) {\n                if ((view.props.editable && !view.props.editable(view.state)) ||\n                    !options.uploadImage) {\n                    return false;\n                }\n                const files = getDataTransferFiles_1.default(event).filter(file => /image/i.test(file.type));\n                if (files.length === 0) {\n                    return false;\n                }\n                const result = view.posAtCoords({\n                    left: event.clientX,\n                    top: event.clientY,\n                });\n                if (result) {\n                    insertFiles_1.default(view, event, result.pos, files, options);\n                    return true;\n                }\n                return false;\n            },\n        },\n    },\n});\nclass Image extends Node_1.default {\n    constructor() {\n        super(...arguments);\n        this.handleWidthChange = ({ node, getPos }, width) => {\n            const src = node.attrs.src;\n            const alt = node.attrs.alt;\n            if (width === node.attrs.width)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                src,\n                width,\n                alt,\n            });\n            view.dispatch(transaction);\n        };\n        this.handleKeyDown = ({ node, getPos }) => event => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                const { view } = this.editor;\n                const pos = getPos() + node.nodeSize;\n                view.focus();\n                view.dispatch(prosemirror_utils_1.setTextSelection(pos)(view.state.tr));\n                return;\n            }\n            if (event.key === \"Backspace\" && event.target.innerText === \"\") {\n                const { view } = this.editor;\n                const $pos = view.state.doc.resolve(getPos());\n                const tr = view.state.tr.setSelection(new prosemirror_state_1.NodeSelection($pos));\n                view.dispatch(tr.deleteSelection());\n                view.focus();\n                return;\n            }\n        };\n        this.handleBlur = ({ node, getPos }) => event => {\n            const alt = event.target.innerText;\n            const src = node.attrs.src;\n            const width = node.attrs.width;\n            if (alt === node.attrs.alt)\n                return;\n            const { view } = this.editor;\n            const { tr } = view.state;\n            const pos = getPos();\n            const transaction = tr.setNodeMarkup(pos, undefined, {\n                src,\n                alt,\n                width\n            });\n            view.dispatch(transaction);\n        };\n        this.handleSelect = ({ getPos }) => event => {\n            event.preventDefault();\n            const { view } = this.editor;\n            const $pos = view.state.doc.resolve(getPos());\n            const transaction = view.state.tr.setSelection(new prosemirror_state_1.NodeSelection($pos));\n            view.dispatch(transaction);\n        };\n        this.component = props => {\n            const { theme, isEditable, isSelected } = props;\n            const { alt, width, src } = props.node.attrs;\n            const ImageComponent = () => {\n                const [test, setTest] = React.useState(null);\n                const imgContainerRef = React.useRef(null);\n                const imgWrapperRef = React.useRef(null);\n                const initialWidth = width ? width : \"75%\";\n                var imageDraggable = false;\n                var isLeftDragging = true;\n                var initialImageX = null;\n                var initialPageX = null;\n                const commitWidth = () => {\n                    imageDraggable = false;\n                    initialImageX = null;\n                    initialPageX = null;\n                    this.handleWidthChange(props, imgWrapperRef.current.style.width);\n                };\n                const handleCoverDrag = (e) => {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    const bounds = imgContainerRef.current.getBoundingClientRect();\n                    if (e.pageX <= bounds.x + 10 ||\n                        e.pageX >= (bounds.x + bounds.width - 10)) {\n                        commitWidth();\n                        return;\n                    }\n                    if (!imageDraggable)\n                        return;\n                    const effectiveX = isLeftDragging ? (initialImageX + (initialPageX - e.pageX)) : (initialImageX + (e.pageX - initialPageX));\n                    let effectivePercent = (effectiveX / imgContainerRef.current.clientWidth) * 100;\n                    if (effectivePercent < 0)\n                        effectivePercent = 0;\n                    else if (effectivePercent > 100 || effectivePercent > 90)\n                        effectivePercent = 100;\n                    imgWrapperRef.current.style.width = effectivePercent + \"%\";\n                };\n                const handleCoverDragStart = (e, isLeft) => {\n                    imageDraggable = true;\n                    isLeftDragging = isLeft;\n                    if (!initialImageX) {\n                        const percentPosition = parseInt(initialWidth, 10);\n                        initialImageX = (percentPosition * imgContainerRef.current.clientWidth) / 100;\n                    }\n                    initialPageX = e.pageX;\n                    e.stopPropagation();\n                    e.preventDefault();\n                };\n                const handleCoverDragEnd = (e) => {\n                    commitWidth();\n                    e.stopPropagation();\n                    e.preventDefault();\n                };\n                return (React.createElement(\"div\", { contentEditable: false, className: \"image\", ref: imgContainerRef, onMouseMove: handleCoverDrag, onMouseUp: handleCoverDragEnd },\n                    React.createElement(ImageWrapper, { className: \"image-block \" + (isSelected ? \"ProseMirror-selectednode\" : \"\"), onClick: isEditable ? this.handleSelect(props) : undefined, ref: imgWrapperRef, style: { width: initialWidth } },\n                        React.createElement(react_medium_image_zoom_1.default, { image: {\n                                src,\n                                alt,\n                                style: {\n                                    display: \"block\",\n                                    width: \"100%\",\n                                    maxHeight: \"100%\",\n                                },\n                            }, defaultStyles: {\n                                overlay: {\n                                    backgroundColor: theme.background,\n                                },\n                            }, shouldRespectMaxDimension: true }),\n                        isEditable && (React.createElement(React.Fragment, null,\n                            React.createElement(ImageLeftBar, { className: \"image-bar\", onMouseDown: (e) => { handleCoverDragStart(e, true); } },\n                                React.createElement(ImageLeftHandle, null)),\n                            React.createElement(ImageRightBar, { className: \"image-bar\", onMouseDown: (e) => { handleCoverDragStart(e, false); } },\n                                React.createElement(ImageRightHandle, null))))),\n                    (isEditable || alt) && (React.createElement(Caption, { onKeyDown: this.handleKeyDown(props), onBlur: this.handleBlur(props), tabIndex: -1, contentEditable: isEditable, suppressContentEditableWarning: true }, alt))));\n            };\n            return (React.createElement(ImageComponent, null));\n        };\n    }\n    get name() {\n        return \"image\";\n    }\n    get schema() {\n        return {\n            inline: true,\n            attrs: {\n                src: {},\n                width: {\n                    default: \"75%\"\n                },\n                alt: {\n                    default: null,\n                },\n            },\n            content: \"text*\",\n            marks: \"\",\n            group: \"inline\",\n            selectable: true,\n            draggable: true,\n            parseDOM: [\n                {\n                    tag: \"div.image\",\n                    getAttrs: (dom) => {\n                        const img = dom.getElementsByTagName(\"img\")[0];\n                        const caption = dom.getElementsByTagName(\"p\")[0];\n                        return {\n                            src: img.getAttribute(\"src\"),\n                            alt: caption.innerText,\n                        };\n                    },\n                },\n            ],\n            toDOM: node => {\n                return [\n                    \"div\",\n                    {\n                        class: \"image\",\n                    },\n                    [\n                        \"div\",\n                        { class: \"image-block \", style: \"width:\" + node.attrs.width },\n                        [\"img\", Object.assign(Object.assign({}, node.attrs), { contentEditable: false })],\n                    ],\n                    [\"p\", { class: \"caption\" }, 0],\n                ];\n            },\n        };\n    }\n    toMarkdown(state, node) {\n        state.write(\"![\" +\n            state.esc((node.attrs.alt || \"\").replace(\"\\n\", \"\") || \"\") +\n            \"](\" +\n            state.esc(node.attrs.src) +\n            \")\" +\n            \"{width=\\\"\" + node.attrs.width + \"\\\"}\");\n    }\n    parseMarkdown() {\n        return {\n            node: \"image\",\n            getAttrs: token => ({\n                src: token.attrGet(\"src\"),\n                width: token.attrGet(\"width\"),\n                alt: (token.children[0] && token.children[0].content) || null,\n            }),\n        };\n    }\n    commands({ type }) {\n        return attrs => (state, dispatch) => {\n            const { selection } = state;\n            const position = selection.$cursor\n                ? selection.$cursor.pos\n                : selection.$to.pos;\n            const node = type.create(attrs);\n            const transaction = state.tr.insert(position, node);\n            dispatch(transaction);\n            return true;\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(IMAGE_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, alt, src] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start - 1, end, type.create({\n                        src,\n                        alt,\n                    }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    get plugins() {\n        return [uploadPlaceholder_1.default, uploadPlugin(this.options)];\n    }\n}\nexports.default = Image;\nconst ImageWrapper = styled_components_1.default.span `\n  position: relative;\n  line-height: 0;\n  display: inline-block;\n`;\nconst ImageLeftBar = styled_components_1.default.div `\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  width: 30px;\n  height: 100%;\n  top: 50%;\n  left: 0px;\n  transform: translate(0, -50%);\n  cursor: col-resize;\n`;\nconst ImageRightBar = styled_components_1.default.div `\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  width: 30px;\n  height: 100%;\n  top: 50%;\n  right: 0px;\n  transform: translate(0, -50%);\n  cursor: col-resize;\n`;\nconst ImageLeftHandle = styled_components_1.default.div `\n  align-self: center;\n  width: 6px;\n  height: 50px;\n  border-radius: 5px;\n  border: 1px solid #FFF;\n  background: rgba(0,0,0,0.5);\n`;\nconst ImageRightHandle = styled_components_1.default.div `\n  align-self: center;\n  width: 6px;\n  height: 50px;\n  border-radius: 5px;\n  border: 1px solid #FFF;\n  background: rgba(0,0,0,0.5);\n`;\nconst Caption = styled_components_1.default.p `\n  border: 0;\n  display: block;\n  font-size: 13px;\n  font-style: italic;\n  color: ${props => props.theme.textSecondary};\n  padding: 2px 0;\n  line-height: 16px;\n  text-align: center;\n  width: 100%;\n  min-height: 1em;\n  outline: none;\n  background: none;\n  resize: none;\n\n  &:empty:before {\n    color: ${props => props.theme.placeholder};\n    content: \"Write a caption\";\n    pointer-events: none;\n  }\n`;\n\n\n//# sourceURL=webpack:///./src/nodes/Image.tsx?");

/***/ })

})